
=== Goals
* Combine the forward-secrecy of symmetric-key updating with the "future-secrecy" of an OTR-like Diffie-Hellman ratchet
* Detect replay / reorder / deletion of messages
* Allow decryption of out-of-order (e.g. delayed) messages with minimal reduction in forward secrecy
* Don't leak metadata such as identities or sequence numbers

{{{
State
------
Each party stores the following values per conversation:

RK           : 32-byte root key which gets updated by DH ratchet
HKs, HKr     : 32-byte header keys (send and recv versions)
NHKs, NHKr   : 32-byte next header keys (")
CKs, CKr     : 32-byte chain keys (used for forward-secrecy updating)
DHIs, DHIr   : ECDH Identity keys
DHRs, DHRr   : ECDH Ratchet keys
Ns, Nr       : Message numbers (reset to 0 with each new ratchet)
PNs          : Previous message numbers (# of msgs sent under prev ratchet)
ratchet_flag : True if the party will send a new ratchet key in next msg


Key Agreement
--------------
 - Parties exchange identity keys (A,B) and handshake keys (A0,A1) and (B0,B1)
 - Parties assign themselves "Alice" or "Bob" roles by comparing public keys
 - Parties perform triple-DH with (A,B,A0,B0) and derive initial keys:
Alice:
  KDF from triple-DH: RK, HKs=<none>, HKr, NHKs, NHKr, CKs=<none>, CKr
  DHIs, DHIr = A, B
  DHRs, DHRr = <none>, B1
  Ns, Nr = 0, 0
  PNs = 0
  ratchet_flag = True
Bob:
  KDF from triple-DH: RK, HKr=<none>, HKs, NHKr, NHKs, CKr=<none>, CKs
  DHIs, DHIr = B, A
  DHRs, DHRr = B1, <none>
  Ns, Nr = 0, 0
  PNs = 0
  ratchet_flag = False


Sending messages
-----------------
Local variables:
  MK  : message key

if ratchet_flag:
  DHRs = generateECDH()
  RK = HASH(RK || ECDH(DHRs, DHRr))
  HKs = NHKs
  NHKs, CKs = KDF(RK)
  PNs = Ns
  Ns = 0
  ratchet_flag = False
MK = HASH(CKs || "0")
msg = Enc(HKs, Ns || PNs || DHRs) || Enc(MK, plaintext)
Ns = Ns + 1
CKs = HASH(CKs || "1")
return msg


Receiving messages
-------------------
Local variables:
  r   : flag (True if DH ratchet was advanced)
  MK  : message key
  Np  : Purported message number
  PNp : Purported previous message number
  CKp : Purported new chain key
  DHp : Purported new DHr
  RKp : Purported new root key
  NHKp, HKp : Purported new header keys

# Try saved keys
if (plaintext = try_skipped_header_and_message_keys()):
  return plaintext

# Decrypt header
if Dec(HKr, header):
  Np = read()
  CKp = CKr
  stage_skipped_header_and_message_keys(HKr, Nr, Np, CKp)
  r = False
elif Dec(NHKr, header):
  if ratchet_flag:
    raise undecryptable()
  Np = read()
  PNp = read()
  DHRp = read()
  stage_skipped_header_and_message_keys(HKr, Nr, PNp, CKp)
  RKp = HASH(RK || ECDH(DHRp, DHRs))
  HKp = NHKr
  NHKp, CKp = KDF(RKp)
  stage_skipped_header_and_message_keys(HKp, 0, Np, CKp)
  r = True
else:
  raise undecryptable()

# Decrypt body
MK = HASH(CKp || "0")
if (!plaintext = Dec(MK, ciphertext)):
  raise undecryptable()

# Update state
commit_skipped_header_and_message_keys()
if r:
  RK = RKp
  HKr = HKp
  NHKr = NHKp
  erase(DHRs)
  DHRr = DHRp
  ratchet_flag = True
Nr = Np + 1
CKr = HASH(CKp || "1")
return plaintext
}}}