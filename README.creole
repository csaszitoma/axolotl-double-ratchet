=== Goals
* Combine the forward-secrecy of symmetric-key updating with the "future-secrecy" of an OTR-like Diffie-Hellman ratchet.
** By "future-secrecy" we mean that a point-in-time leak of key material to a passive eavesdropper will be "healed" by the introduction of new ECDH keys.
* Improve on OTR's future-secrecy with a "2-step" ratchet (instead of "3-step")
* Detect replay / reorder / deletion of messages
* Allow decryption of out-of-order (delayed) messages with minimal reduction in forward secrecy
* Don't leak metadata in cleartext (such as identities or sequence numbers)

{{{
State
------
Each party stores the following values per conversation:

RK           : 32-byte root key which gets updated by DH ratchet
HKs, HKr     : 32-byte header keys (send and recv versions)
NHKs, NHKr   : 32-byte next header keys (")
CKs, CKr     : 32-byte chain keys (used for forward-secrecy updating)
DHIs, DHIr   : ECDH Identity keys
DHRs, DHRr   : ECDH Ratchet keys
Ns, Nr       : Message numbers (reset to 0 with each new ratchet)
PNs          : Previous message numbers (# of msgs sent under prev ratchet)
ratchet_flag : True if the party will send a new ratchet key in next msg


Key Agreement
--------------
 - Parties exchange identity keys (A,B) and handshake keys (A0,A1) and (B0,B1)
 - Parties assign themselves "Alice" or "Bob" roles by comparing public keys
 - Parties perform triple-DH with (A,B,A0,B0) and derive initial keys:
Alice:
  KDF from triple-DH: RK, HKs=<none>, HKr, NHKs, NHKr, CKs=<none>, CKr
  DHIs, DHIr = A, B
  DHRs, DHRr = <none>, B1
  Ns, Nr = 0, 0
  PNs = 0
  ratchet_flag = True
Bob:
  KDF from triple-DH: RK, HKr=<none>, HKs, NHKr, NHKs, CKr=<none>, CKs
  DHIs, DHIr = B, A
  DHRs, DHRr = B1, <none>
  Ns, Nr = 0, 0
  PNs = 0
  ratchet_flag = False


Sending messages
-----------------
Local variables:
  MK  : message key

if ratchet_flag:
  DHRs = generateECDH()
  RK = HASH(RK || ECDH(DHRs, DHRr))
  HKs = NHKs
  NHKs, CKs = KDF(RK)
  PNs = Ns
  Ns = 0
  ratchet_flag = False
MK = HASH(CKs || "0")
msg = Enc(HKs, Ns || PNs || DHRs) || Enc(MK, plaintext)
Ns = Ns + 1
CKs = HASH(CKs || "1")
return msg


Receiving messages
-------------------
Local variables:
  MK  : message key
  Np  : Purported message number
  PNp : Purported previous message number
  CKp : Purported new chain key
  DHp : Purported new DHr
  RKp : Purported new root key
  NHKp, HKp : Purported new header keys

if (plaintext = try_skipped_header_and_message_keys()):
  return plaintext

if HKr != <none> and Dec(HKr, header):
  Np = read()
  CKp, MK = stage_skipped_header_and_message_keys(HKr, Nr, Np, CKr)
  if not Dec(MK, ciphertext):
    raise undecryptable
else:
  if ratchet_flag or not Dec(NHKr, header):
    raise undecryptable()
  Np = read()
  PNp = read()
  DHRp = read()
  stage_skipped_header_and_message_keys(HKr, Nr, PNp, CKr)
  RKp = HASH(RK || ECDH(DHRp, DHRs))
  HKp = NHKr
  NHKp, CKp = KDF(RKp)
  CKp, MK = stage_skipped_header_and_message_keys(HKp, 0, Np, CKp)
  if not Dec(MK, ciphertext):
    raise undecryptable()
  RK = RKp
  HKr = HKp
  NHKr = NHKp
  DHRr = DHRp
  erase(DHRs)
  ratchet_flag = True
commit_skipped_header_and_message_keys()
Nr = Np + 1
CKr = CKp
return read()
}}}

=== IPR

The Axolotl specification (this wiki) is hereby placed in the public domain.

=== Acknowledgements

Joint work with Moxie Marlinspike.  Thanks to Adam Langley for discussion and improving the receiving algorithm.

